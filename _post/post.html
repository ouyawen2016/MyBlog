<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Java之面向对象2</title>
</head>
<body>
<div id="wmd-preview" class="wmd-preview"><div class="md-section-divider"></div><div class="md-section-divider"></div><h1 data-anchor-id="kvhe" id="java之面向对象2">Java之面向对象2</h1><p data-anchor-id="x4e0"><code>Java</code></p><hr><div class="md-section-divider"></div><h3 data-anchor-id="47sm" id="复习对象的创建和使用">复习：对象的创建和使用</h3><ul data-anchor-id="b09i">
<li>必须用new关键字创建对象</li>
<li>使用对象.成员变量或方法（参数列表）来调用对象方法</li>
<li>同一个类的每个对象有不同的成员变量存储空间</li>
<li>非静态方法是针对每个对象进行调用 <br>
不加static的方法，必须new一个对象才能调 </li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="7dr2" id="关于内存空间">关于内存空间</h3><ul data-anchor-id="n4fu">
<li>栈内存：放方法的局部变量，在方法调用结束以后，会消失</li>
<li>堆内存：放new出来的对象，没有引用的对象，会被清理</li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="j4q3" id="this关键字">this关键字</h3><ul data-anchor-id="sidr">
<li>表示使用该方法对象的引用，指向自身的引用 <br>
可理解为支对支的引用，可在该类的一个方法中直接引用另一个方法。</li>
<li>可以省略</li>
<li>有时可以用this处理方法中成员变量和参数重名的情况 <br>
当确定不了变量指的是对应哪个声明时，就近声明原则。</li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="58vc" id="static关键字">static关键字</h3><ul data-anchor-id="6hqb">
<li>在类中，用static声明的成员变量为静态成员变量，它为该类的公用变量，在第一次使用时被初始化，对于该类的所有对象来说，static对象只有一份，保存在data_seg里，不再在堆上。</li>
<li>用static声明的方法为静态方法，在调用该方法时不会将对象的引用传递给它，所以在static方法中，不可访问非静态成员，非静态的方法专属于对象，想调用则要new一个对象出来</li>
<li>可以通过对象引用或类名访问静态成员</li>
<li>可以结合自加用来计数  <br>


<blockquote class="white-blockquote">
  非静态和静态的很大区别就在于此， <br>
  1.当成员变量不再是静态的时候，其值会一次次被重新定义，（这和C语言里面，我对与static的理解很像，但其本质的区别是存储位置） <br>
  2.必须创建对象才能被调用，而静态可以直接被调用</blockquote></li>
  </ul><div class="md-section-divider"></div><h3 data-anchor-id="euq6" id="前面几节的历史遗留问题">前面几节的历史遗留问题</h3><div class="md-section-divider"></div><h3 data-anchor-id="oqla" id="package和import">package和import</h3><ul data-anchor-id="7ll7">
<li>包的存在是为了避免不同开发者起名重复，包的名字默认是com.公司域名，域名不能重复所以包名就不会重复了。</li>
<li>com.公司域名.项目名.你想叫啥.还可以往下写</li>
<li>import是引入，开头写上import包名.类，就可以直接使用该类或者import.*可以用该包所有</li>
</ul><div class="md-section-divider"></div><h4 data-anchor-id="ucep" id="总结">总结：</h4><p data-anchor-id="5e03">如果要把类放在包里，package，编译出来的class文件存放位置必须与包名一致，class必须最上层的位于classpath <br>
想在另一个类里用必须写全名字 <br>
执行一个类也要写全</p><div class="md-section-divider"></div><h4 data-anchor-id="a3e3" id="类的继承和权限控制">类的继承和权限控制</h4><p data-anchor-id="484w">java中使用extends关键字实现类的继承， <br>
修饰符+class+类名+extends+父类{ <br>
* 通过继承，子类自动拥有基类的所有成员，子类要比父类要大</p><div class="md-section-divider"></div><h5 data-anchor-id="5wb0" id="访问控制">访问控制</h5><table data-anchor-id="z65y" class="table table-striped-white table-bordered">
<thead>
<tr>
 <th>修饰符</th>
 <th style="text-align:center;">类内部</th>
 <th style="text-align:center;">包</th>
 <th>子类</th>
 <th>任何</th>
</tr>
</thead>
<tbody><tr>
 <td>private</td>
 <td style="text-align:center;">O</td>
 <td style="text-align:center;">X</td>
 <td>X</td>
 <td>X</td>
</tr>
<tr>
 <td>default</td>
 <td style="text-align:center;">O</td>
 <td style="text-align:center;">O</td>
 <td>X</td>
 <td>X</td>
</tr>
<tr>
 <td>protected</td>
 <td style="text-align:center;">O</td>
 <td style="text-align:center;">O</td>
 <td>O</td>
 <td>X</td>
</tr>
<tr>
 <td>public</td>
 <td style="text-align:center;">O</td>
 <td style="text-align:center;">O</td>
 <td>O</td>
 <td>O</td>
</tr>
</tbody></table><div class="md-section-divider"></div><h4 data-anchor-id="ovol" id="对于class的权限修饰只可以用public和default">对于class的权限修饰只可以用public和default</h4><ul data-anchor-id="dk29">
<li>public类可以在任意地方被访问</li>
<li>default类只可以被同一个包内部的类访问</li>
</ul><div class="md-section-divider"></div><h4 data-anchor-id="dj27" id="方法的重写">方法的重写</h4><ul data-anchor-id="itzx">
<li>在子类中可以根据需要对从基类中继承来的方法进行重写</li>
<li>重写方法必须和被重写方法有一样的返回值，参数表和方法名</li>
<li>重写方法不能使用比被重写方法更严格的访问权限，就范围不能缩小</li>
</ul><div class="md-section-divider"></div><h4 data-anchor-id="503d" id="super关键字">Super关键字</h4><ul data-anchor-id="jo3p">
<li>super指引用子类所继承的父类中的方法</li>
<li>子类必须调用父类的构造方法，先有爸爸才有你</li>
<li>子类可以在自己的构造方法中使用super（argument_list）调用</li>
<li>如果用super必须写在子类构造方法第一行 </li>
</ul><div class="md-section-divider"></div><h4 data-anchor-id="ktoi" id="动态绑定与多态">动态绑定与多态</h4><p data-anchor-id="0xbz">动态绑定是指在执行期间，判断所引用对象实际的类型，根据其实际的类型调用其相应的方法 <br>
随着new出来的对象而更改方法  <br>
所以才说</p><blockquote data-anchor-id="o936" class="white-blockquote">
  <p>多态的条件 <br>
   1.要有继承 <br>
  2.要有重写 <br>
  3.父类引用指向子类对象</p>
</blockquote><div class="md-section-divider"></div><h4 data-anchor-id="7xcg" id="抽象类">抽象类</h4><ul data-anchor-id="tkvq">
<li>用abstract关键字来修饰一个类时，这个类叫做抽象类，用abstract来修饰一个方法时，就叫抽象方法</li>
<li>含有抽象方法的类必须被声明为抽象类，抽象类必须被继承，抽象方法必须被重写</li>
<li>抽象类不能被实例化，就不能new</li>
<li>抽象方法只需声明，而不需实现 <br>
抽象类的存在意义就是被继承</li>
</ul><div class="md-section-divider"></div><h4 data-anchor-id="i1t2" id="final关键字">final关键字</h4><ul data-anchor-id="ifd5">
<li>final的变量值不能被改变，egfinal的成员变量，final的局部变量（形参）</li>
<li>final的方法不能够被重写</li>
<li>final的类不能够被继承</li>
</ul><div class="md-section-divider"></div><h4 data-anchor-id="4qt4" id="接口">接口</h4><p data-anchor-id="mwqb">为了解决单继承，接口是抽象方法和常量值的定义的集合，可视为一种特殊的抽象类，这种抽象类只有变量和方法的定义，没有变量和方法的实现</p><pre data-anchor-id="817v"><code>public interface Runner{
public static final int id = 1;
public void strart();
public void run();
public void stop();
}
</code></pre><p data-anchor-id="oql7">接口可以多重实现，一个类可以实现多个接口  <br>
尽量不要实现两个有重名的方法的类</p><div class="md-section-divider"></div><h4 data-anchor-id="6nam" id="异常的概念">异常的概念</h4><ul data-anchor-id="v4jn">
<li>Java异常是Java提供的处理程序运行期出现的错误的方法</li>
<li>感觉跟编译器报错差不多（数组下标越界，除零）</li>
<li>设计良好的程序应该在出错的时候提供处理错误的方法，友好一点</li>
<li>发生异常事件会抛出异常 （throw）</li>
<li>可以用try，尝试运行某段，通过catch（ ae）{处理这个异常的方法}</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="199n"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">try</span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="typ">System</span><span class="pun">.</span><span class="pln">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="lit">2</span><span class="pun">/</span><span class="lit">0</span><span class="pun">);</span></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">catch</span><span class="pun">(</span><span class="typ">ArithmeticException</span><span class="pln"> ae</span><span class="pun">){</span></code></li><li class="L3"><code class="language-java"><span class="pln">    </span><span class="typ">System</span><span class="pun">.</span><span class="pln">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"系统正在维护中，请与管理员联系"</span><span class="pun">);</span></code></li><li class="L4"><code class="language-java"><span class="pln">    ae</span><span class="pun">.</span><span class="pln">printStackTrace</span><span class="pun">();</span></code></li><li class="L5"><code class="language-java"><span class="pln">    </span><span class="pun">}</span></code></li></ol></pre></div>
</body>
</html>