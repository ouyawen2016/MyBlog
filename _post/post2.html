<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>SID假前小充电</title>
</head>
<body>
<div id="wmd-preview" class="wmd-preview"><div class="md-section-divider"></div><div class="md-section-divider"></div><h1 data-anchor-id="w790" id="sid假前小充电">SID假前小充电</h1><p data-anchor-id="3bup"><code>Java</code></p><div class="md-section-divider"></div><h2 data-anchor-id="kex4" id="java-基础常识补点">Java 基础常识补点</h2><ul data-anchor-id="8j4i">
<li><p>Java 的跨平台是通过什么实现的？ <br>
实现关键在Java虚拟机（JVM）。<em>.Java文件编译生成</em>.class文件，是字节码文件，与平台无关。所有平台上的JVM向编译器提供相同接口，而编译器只需面对JVM，生成与平台无关的字节码，然后由JVM来解释执行。</p></li>
<li><p>JDK、JRE、JVM 的全称是什么？ <br>
JDK:Java SE Development 即Java标准版开发包 <br>
JRE:Java Runtime Environment，即Java运行时环境 <br>
JVM:Java Virtual Machine ,即Java虚拟机 <br>
JDK包含JRE,JRE包含JVM。</p></li>
<li>public class 的类名必须跟文件名保持一致吗？ <br>
是。但在我个人理解看来，倒不如说是文件名和 public class 的类名保持一致。一个文件里只能有一个public 类，当文件中没有public 类的时候可以随意命名。</li>
<li>一个 Java 源文件可以写多个 Class 吗？编译后会不会生成多个 Class 文件？ <br>
可以。会，每个类会生成一个.class文件。</li>
</ul><div class="md-section-divider"></div><h4 data-anchor-id="b2ou" id="在实际用命令行编译的时候我们用javac似乎是在对java文件名不带拓展名实际上是对类名-即javac-类名">在实际用命令行编译的时候，我们用Javac似乎是在对Java文件名不带拓展名,实际上是对类名 即Javac 类名</h4><ul data-anchor-id="fx48">
<li>编程时，为什么需要注释？Java 中注释的类型有哪些？ <br>
整理思路，增加可读性。基本分为单行注释，多行注释，文档注释。 <br>
// 单行注释 <br>
/*多行 <br>
注释 <br>
<em>/ <br>
/*</em> <br>
*文档注释 <br>
*/ <br>
文档注释可利用javadoc提取出来生成API文档 <br>
利用javadoc标记如@author,@param,@return等</li>
</ul><div class="md-section-divider"></div><h2 data-anchor-id="km51" id="面向对象一">面向对象（一）</h2><ul data-anchor-id="xycr">
<li><p>简述面向对象和面向过程的区别和联系？</p>

<ul><li><p>区别：</p>

<blockquote class="white-blockquote">
  <p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 <br>
  可以拿生活中的实例来理解面向过程与面向对象，例如五子棋，面向过程的设计思路就是首先分析问题的步骤：1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用不同的方法来实现。 <br>
  如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。 <br>
  可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。 <br>
  ——《C#编程词典》</p>
</blockquote></li>
<li><p>联系：都存在调用函数（方法）解决某个问题的思想，所以面向对象也是建立在函数的基础上。</p></li></ul></li>
<li>对象和类的关系时？ <br>
类（class）是某一批对象（object）的抽象，而对象是类的实例。对于一个类而言，可以包含三种最常见的成员：构造器，成员变量，方法。 <br>
成员变量用于定义该类的实例包含的状态数据，方法用于定义该类或该类实例的行为特征及功能实现。构造器用于构造该类的实例，通过new来调用得到对象。 <br>
构造器不是必须写的，不写，Java会自动为该类提供一个构造器， <br>
static 多译为静态，真正的作用其实是用于区别成员变量，方法，内部类和初始化块到底属于类还是属于实例。有，属于类，没有，属于实例。静态成员不能直接访问非静态成员，可见 Java之面向对象</li>
<li>堆和栈的特点是什么？分别存放什么内容？ <br>
栈内存：放方法的局部变量，在方法调用结束以后，会消失 <br>
堆内存：放new出来的对象，没有引用的对象，会Java垃圾回收机制处理</li>
<li>局部变量使用之前，需要手动初始化吗？ <br>
系统不会对局部变量初始化，必须由程序员显式初始化</li>
<li>Java 中如果不手动指定成员变量的值，系统会自动初始化，那么初始化的规则是？</li>
</ul><table data-anchor-id="gq50" class="table table-striped-white table-bordered">
<thead>
<tr>
 <th>类型</th>
 <th style="text-align:center;">默认值</th>
</tr>
</thead>
<tbody><tr>
 <td>Boolean</td>
 <td style="text-align:center;">false</td>
</tr>
<tr>
 <td>Char</td>
 <td style="text-align:center;">'\u0000'(null)</td>
</tr>
<tr>
 <td>byte</td>
 <td style="text-align:center;">(byte)0</td>
</tr>
<tr>
 <td>short</td>
 <td style="text-align:center;">(short)0</td>
</tr>
<tr>
 <td>int</td>
 <td style="text-align:center;">0</td>
</tr>
<tr>
 <td>long</td>
 <td style="text-align:center;">0L</td>
</tr>
<tr>
 <td>float</td>
 <td style="text-align:center;">0.0f</td>
</tr>
<tr>
 <td>double</td>
 <td style="text-align:center;">0.0d</td>
</tr>
</tbody></table><p data-anchor-id="eoi0">注意，final修饰的成员变量必须被赋初值。 <br>
* 构造方法如何被调用？ <br>
构造方法，或译作构造器，其实是一种特殊的方法，不需要返回值，返回的是一个对象。用new来调用，构造出一个新对象。 <br>
e.g.</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="iyic"><ol class="linenums"><li class="L0"><code class="language-java"><span class="pln">person p </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> person</span><span class="pun">();</span></code></li></ol></pre><ul data-anchor-id="ef2p">
<li>系统一定会给我们添加无参数的构造方法吗?请详细解释。 <br>
不一定，只有在我们没有定义构造方法的时候，系统自动</li>
<li>构造方法能不能重载？ <br>
能，和普通方法一样用。同名不同参数列表。</li>
<li>this 在普通方法中，指的是哪个对象？在构造方法中，指的是？ <br>
指的是调用该方法的对象，构造方法中指的是该构造方法正在初始化的对象，利用this可在一个构造方法中，调用另一个构造方法，从而提高代码的重用性</li>
<li>静态初始化块和 main 方法哪个先被执行？ <br>
静态初始化块。它的执行是类的初始化的一部分。只有类初始化完了，才能用。而普通初始化块在构造器之前执行</li>
<li>一个构造方法调用另一个构造方法怎么调用？this() 这样的调用方式必须位于第一句吗？ <br>
e.g.</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="t3df"><ol class="linenums"><li class="L0"><code class="language-java"><span class="pln"> </span><span class="kwd">public</span><span class="pln"> person</span><span class="pun">(</span><span class="typ">Sting</span><span class="pln"> name</span><span class="pun">,</span><span class="typ">String</span><span class="pln"> age</span><span class="pun">){</span></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">name </span><span class="pun">=</span><span class="pln">name</span><span class="pun">;</span></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">age </span><span class="pun">=</span><span class="pln">age</span><span class="pun">;</span></code></li><li class="L3"><code class="language-java"><span class="pun">}</span></code></li><li class="L4"><code class="language-java"><span class="kwd">public</span><span class="pln"> person </span><span class="pun">(</span><span class="typ">String</span><span class="pln"> name</span><span class="pun">,</span><span class="typ">String</span><span class="pln"> age</span><span class="pun">,</span><span class="typ">String</span><span class="pln"> height</span><span class="pun">){</span></code></li><li class="L5"><code class="language-java"><span class="pln">    </span><span class="kwd">this</span><span class="pun">(</span><span class="pln">name</span><span class="pun">,</span><span class="pln">age</span><span class="pun">);</span><span class="com">//直接使用另一个构造器的代码</span></code></li><li class="L6"><code class="language-java"><span class="pln">    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">height </span><span class="pun">=</span><span class="pln"> height</span><span class="pun">;</span></code></li><li class="L7"><code class="language-java"><span class="pun">}</span></code></li></ol></pre><p data-anchor-id="b712">必须在第一句且只能在构造器里用。</p><ul data-anchor-id="63ax">
<li>package 的两个作用是什么？ <br>
<ul><li>提供多重命名空间，解决类名冲突</li>
<li>划分功能相近的类，形成逻辑上的类库单元</li></ul></li>
<li>import static 叫做静态导入，那么其作用是什么？ <br>
导入指定类某个或全部静态成员变量或方法</li>
<li>请详细快速的说明 private、default、protected、public 的区别。</li>
</ul><div class="md-section-divider"></div><h5 data-anchor-id="5qzg" id="访问控制">访问控制</h5><table data-anchor-id="oti2" class="table table-striped-white table-bordered">
<thead>
<tr>
 <th>修饰符</th>
 <th style="text-align:center;">所在类内部</th>
 <th style="text-align:center;">包</th>
 <th>所在类的子类</th>
 <th>任何</th>
</tr>
</thead>
<tbody><tr>
 <td>private</td>
 <td style="text-align:center;">O</td>
 <td style="text-align:center;">X</td>
 <td>X</td>
 <td>X</td>
</tr>
<tr>
 <td>default</td>
 <td style="text-align:center;">O</td>
 <td style="text-align:center;">O</td>
 <td>X</td>
 <td>X</td>
</tr>
<tr>
 <td>protected</td>
 <td style="text-align:center;">O</td>
 <td style="text-align:center;">O</td>
 <td>O</td>
 <td>X</td>
</tr>
<tr>
 <td>public</td>
 <td style="text-align:center;">O</td>
 <td style="text-align:center;">O</td>
 <td>O</td>
 <td>O</td>
</tr>
</tbody></table><div class="md-section-divider"></div><h4 data-anchor-id="9nr6" id="对于外部类的权限修饰只可以用public和default">对于外部类的权限修饰只可以用public和default</h4><p data-anchor-id="a294">因为没有处在任何一个类里，也就没有所在类里，所在类的子类这两个范围 <br>
-public类可以在任意地方被访问 <br>
 default类只可以被同一个包内部的类访问</p><ul data-anchor-id="1scf">
<li>javabean 就是只包含属性和相关 getter/setter 方法，不包含业务逻辑处理的被，这种说法对吗？ <br>
不对。JavaBean可以说是一种封装良好的规范。 <br>
必须满足： <br>
每个成员变量都被private修饰，对应public修饰的setter和getter方法 <br>
它重点不在于含不含业务逻辑处理，而在于是否被良好封装。</li>
</ul></div>
</body>
</html>